静态画面  
---
### HMI模块的解耦  
这一次开始真正接触这个sample的核心问题——应该如何来设计一个HMI代码框架。  

现在有了哪些基础？两任务结构（外部处理任务、描画任务）、两任务间的通信机制（同步MessageQueue）、描画的驱动（基于X11的画点、画线、画字符的接口），有了这些，一个基本的解耦的HMI模块的雏形其实已经初具模样了，可以考虑在描画任务的内部如何去抽象画面描画的事情了。  

不过且慢，为什么说目前的代码结构中描画任务已经和其他任务初步解耦了呢？有必要再唠叨一下这个问题。想象一个刚接手某系统HMI工作的新同事，他会怎么考虑从触摸屏接收消息并在触摸屏上进行描画操作呢？假设他要在一个ID为SCREEN_TEST1的画面接收触摸屏的按下消息，并据此显示一个内容为“Welcome to this sample!”的Label，他很可能会这样做。  
```C++
int main()
{
	while(1) {
		Event ev = GetFromTouchPannel();
		if (ev == EVENT_PUSH_DOWN) {
			if (screnn_id == SCREEN_TEST1) {
				DrawRect(10, 30, 300, 80, back_color);
				DrawString(35, 75, "Welcome to this sample!", FONT_MIDDLE, fore_color, back_color);
			}
		}
	}
}
```
以上这段代码是一位学过C语言的程序员最可能想到的实现方法，从捕捉触摸屏事件到判断事件，再到判断画面，最后到对屏幕进行描画，如此简练、漂亮的就完成了全部功能，这还有啥讨论的呢？如果所有事件与画面都是永恒不变的，这种面向过程式的实现是最容易理解，也是最简捷的，可一旦考虑到变化与协同开发，采用这种思路就很不明智了。这里面会存在很多问题，比如：  
1. 当事件增加的时候是否要修改main函数？  
2. 当画面增加的时候是否要修改main函数？  
3. 当Label字符串改变的时候是否要修改main函数？  
4. ……  

这其中最大的一个问题是，如果外部处理（比如测量、通信等，相对于描画功能）导致事件的任何变化都要影响到描画处理，那么对于外部事件的处理和描画处理就无法分别交给两位同事去完成，也就是说，事件的处理和描画的处理形成了一砣代码，很显然，随着变化的增加，这砣代码会变得不堪入目。   

可是事情明明不是这样的，从感觉上来说外部事件和画面的描画是两个基本独立的过程，不是吗？为啥代码会形成这样的局面呢？如果考虑到这里，就渐渐接近了面向对象的第一个基本概念了，即所谓“封装”。要想把两个功能上独立的代码块切分开来，就必须在概念上对这两个功能进行界定，划清它们的边界。  

再来回头仔细思考一下（外部）事件处理和描画处理这两个功能。虽然通常来说，按下触摸屏产生事件，然后画面判断此事件进行描画，这似乎是一个串行的过程，但这两部分的动作却没有必然的联系，换句话说，触摸屏事件即使发生了，画面描画也未必会进行（按下画面中的非动作控件），而画面描画发生，也并非都是触摸屏事件导致的（比如测量数据的刷新）。总的来说，这两件事本就不应该是一个绝对同步的串行处理关系。但是它们之间的确存在某种联系，在某些触摸屏事件发生后就要进行描画处理。分析到这儿，事情逐渐清晰了，没关系的两个功能块应该各自独立被“封装”起来，而它们之间的联系则需要作为沟通的“接口”，这个步骤通常被称为解耦。  

具体到这个例子，外部事件处理和描画处理应该被描述成两个模块，它们之间的接口就是各种事件。也就是说，外部处理模块作为事件的生产者只要实现到把事件丢给描画模块即可，它不需要关心要不要描画，怎么描画这些本就不应该由它考虑的事情。而描画模块作为事件的消费者，接收各种事件，并以此来判断该如何描画，而对于这些事件如何产生，它也毫不关心。这其实就是我们最初划分的两个任务（控制任务和描画任务），前面已经完成了这部分工作，只不过那时还没有对为什么要如此划分进行深入讨论罢了。  

好了，上面这些讨论都是最顶层设计（任务级）的解耦考虑，下面来看看，站在描画任务的内部又该如何继续解耦。  
 
### 描画世界的抽象  
现在进入到描画任务的内部，来考虑已经接收到了一个画面表示（画面迁移）的消息，在这个消息的条件处理分支中，要描画整个画面了。对这里的例子来说，就是要在320x240尺寸的LCD屏幕上，在起始坐标（10，30）的位置描画一个长为300，高为80的Label，在它的中央显示“Welcome to this sample!”。当然，在描画这个Label前，还要描画出这个画面的背景。  

有人说不就是上面调用的两个驱动函数吗？这有啥可抽象的呢？  
```C++
DrawRect(10, 30, 300, 80, back_color);
DrawString(35, 75, "Welcome to this sample!", SC_FONT_MIDDLE, fore_color, back_color);
```
问题是如果我想在画面上再增加一个Label怎么办？注意了，还是需求的变化导致的问题。变化还不止这一种，因为将来的其它画面也需要画类似的Label，如果不同的画面由不同的程序员来实现，难道需要每个人重复来写上面这两句话吗？  

使用过Windows界面编程的程序员肯定会很快想到显示控件这个概念，这里的Label就是一种显示控件。为啥要抽象出控件的概念来呢？因为一种控件通常都有相同的操作，而画面往往是由多个控件来组成的，这些控件的数量可能很多，但它们通常都属于有限的几个种类，比如Label、Button、Combox、Textbox等等。对于同属一个种类但表示不同数据的控件分别编程显然是不明智的，这种抽象很容易被理解。  

稍有不同的是Windows已经将这些不同的控件实现好了，我们只要拿来实例化即可，如果我们从头来实现的话，这个名叫Label的控件类要怎么写呢？  

先来考虑下描画Label背景这件事。本来描画背景就是用某个特定的前景色和背景色画出一个矩形，在Label控件类中自己画就好了，但是不妨再多想想，那描画其它控件，如Button、Textbox，是不是也要描画这种矩形似的背景呢？这样看来背景描画这件事好像超越了某个特定控件的处理，而上升为全体控件的一种共同处理，那么这样考虑的话，背景描画放在Label这个层级的类中显然不太好。  

好了，这已经涉及到了面向对象的第二个基本概念，即“继承”。此时需要一个在Label和Button控件之上的抽象概念，这不就是控件这个概念本身吗？换句话说，如果先定义Parts基类，将背景描画方法放在Parts基类中，而将其它具体的Label类、Button类等从这个Parts基类继承而来，这样就解决了各种控件描画的共通处理问题。

再考虑另一个问题，当画面中存在很多个控件的时候，画面整体描画这个操作应该如何进行呢？就是挨个画出每个控件呗。这个回答当然没错，但如果Label、Button、Textbox等等控件的实现完全没有内在联系的话，又该如何完成这个整体画面的描画呢？比如一个画面存在2个Label、2个Button、6个Textbox的情况下，难道要在画面描画的函数中像下面这样来操作吗？  
```C++
SCLabel		label[2];
SCButton	button[2];
SCTextbox	textbox[6];

for (int i=0; i<2; ++i) label[i].Draw();
for (int i=0; i<2; ++i) button[i].Draw();
for (int i=0; i<6; ++i) textbox[i].Draw();
```
这样看起来太Low了吧？不是已经有了Parts基类这个家伙吗？能不能用它来统一生成不同的控件，然后在一个循环中就完成所有这些控件的描画呢？恭喜你，如果想到里，就接近了面向对象的第三个基本概念，即“多态”。多态要用到虚函数的概念，这个就不在此啰嗦了。总之，使用了多态性质的代码，看起来会像下面这样：  
```C++
SCParts* parts[10];
parts[0] = new SCLabel();
parts[1] = new SCLabel();
parts[2] = new SCButton();
parts[3] = new SCButton();
parts[4] = new SCTextbox();
……
parts[9] = new SCTextbox();

for (int i=0; i<10; ++i) parts[i]->Draw();
```

画面中的构成元素已经有了上述看上去还不错的解决方案，再来仔细思考一下上面最后一个问题。一个存在着多个控件的画面应该怎样被描画出来呢？你可能会问“上面不是已经给出实现的代码了吗？”，不错，真正描画的时候基本就是这样来操作，但现在的问题是，这个描画的操作应该放在哪里呢？  

这还要回到描画任务的整体架构。前面说了，现在想象的情景是描画任务收到了一个画面迁移消息，它打算要画这个画面了。怎么做呢？直接调用上面那一堆控件描画的代码吗？考虑一下这有什么问题。  
1. 不同的画面包含的控件不同，需要在描画任务的消息处理中区分不同的画面吗？  
2. 一个画面对应一个什么东东呢？一组由不同控件描画处理构成的画面描画函数吗？还是一个特定的画面类？  
3. 画面本身的背景描画怎么办？  

在这一堆问题中，你可能隐隐有所感觉，画面这家伙本身就该抽象为一个类，Windows里也有这个家伙，就是Window类。仿照前面控件的设计思路，Window可以先实现一个基类，每一个要具体实现的画面都从这个Window基类继承而来。那么Window基类中都可以实现哪些共通的操作呢？  

可能首先会想到，背景描画方法在Window基类中实现肯定没问题，因为在这个例子中几乎所有画面的背景都差不多，基本采用单色填充320x240尺寸的矩形即可，这种操作不把它共通到基类中肯定会被同行嘲笑的。  

前景描画该怎么办呢？每个画面的前景铁定是不同的啊，这个没法共通了吧？你肯定会想，这也没必要共通啊，在每个Window子类中实现各自画面的描画，然后在消息处理中使用多态特性操作画面的描画不就OK了吗？这样当然没问题，但还是那句话，功能都能实现，设计却是天差地别。再说了，辛辛苦苦抽象出来的Window基类，难道就只能承担背景描画这种小儿科的功能吗？别急，最精彩的马上就要到了，这正是某系统HMI设计的巧妙之处。  

如果把画面的前景描画再进行一次庖丁解牛式的解析，你可能会发现，前景的描画其实就是顺次进行一堆控件个体的描画，换句话说，在Window基类中如果有这样一个结构，它记录了画面所包含的所有控件，那不就可以在基类中按照这个结构顺藤摸瓜来完成前景描画了吗？这是个非常惊人的思路，说它惊人，是因为它在抽象层面上已经甩出了普通程序员好几条街了。  

不胡扯了，长话短说吧，其实这就是Window基类中实现的一个双向链表结构，用它来管理每个特定画面的所有控件。为啥用双向链表？很简单，控件的数量无法事先确定，因为不同的画面会有不同数量的控件。另外，由于我们处于嵌入式系统中，考虑到尽量减少内存使用的这一原则，使用双向链表已经是最经济的了。当然，它的一个缺陷是，牺牲了检索的效率。  

要注意，虽然这个链表结构是定义在Window基类中的，但是向这个链表追加表项却必须在每个特定的Window子类中完成，因为Window基类当然不知道每个特定的Window子类中都存在哪些控件。可以把向链表追加表项这一操作定义为向链表注册控件，注册和取消注册的方法由基类提供，但由子类调用，这样一来，一整套注册控件与描画控件分离的画面组织架构就形成了。  

还少点什么吗？控件的位置、颜色、字体等属性由谁来管理呢？还是由控件自己来管理比较合适，因为这些属性都是绑定在每一个特定画面的特定控件之上的。如何区分不同的画面以及在其上的不同控件呢？还需要给它们都赋以一个唯一的ID，这样管理起来才比较方便，否则只能记录每个画面和控件的地址了。  

以上讨论了关于静态画面描画的几乎所有关键问题点了，下面给出主要的几个类的定义。  
```C++
class SCParts : public SCCore {
public :
	SCParts(const short id, const SCRect& area,
			const XColor fore_color = COLOR(Black),
			const XColor back_color = COLOR(Transparent));
	virtual ~SCParts();

	virtual bool	Draw(void) = 0;
	virtual bool	DrawBackground(void);
	virtual void	Initialize() {}

	SCBoard*		Parent(void) const {return(m_parent);}
	void			Parent(SCBoard* parent) {m_parent = parent;}
	SCParts*		Next(void) const {return(m_next);}
	void			Next(SCParts* next) {m_next = next;}
	SCParts*		Prev(void) const {return(m_prev);}
	void			Prev(SCParts* prev) {m_prev = prev;}
	short			GetID() const {return(m_id);}

protected :
	short			m_id;			// part ID
	SCBoard*		m_parent;		// father screen
	SCParts*		m_next;			// next part by register sequence
	SCParts*		m_prev;			// previous part by register sequence
	XColor			m_fore_color;	// foreground color
	XColor			m_back_color;	// background color
};

class SCBoard : public SCCore {
public :
	SCBoard(const SCRect& area, const short id = -1); // -1: illegal ID
	virtual ~SCBoard();

	void			RegistParts(SCParts* target);
	void			UnregistParts(SCParts* target);
	void			DestroyParts(SCParts* target);
	void			DestroyAllParts(void);
	
	void			Initialize(void);
	virtual bool	Draw(void);
	virtual bool	DrawBackground(void);
	SCParts*		GetChild(void) const {return(m_child);}
	SCParts*		GetChild(const unsigned short x, const unsigned short y) const;
	SCParts*		GetChild(const SCPoint& point) const;
	SCParts*		GetChild(const short id) const;
	SCParts*		GetLastChild(void) const;

	short			GetScreenID() {return(m_screen_id);}

protected :
	short			m_screen_id;	// screen ID
	SCParts*		m_child;		// child parts
	SCPoint			m_touch_point;	// touch point (for Callback)
};
```


面向对象设计原则（摘录）  
---
### 任务划分  
在基于RTOS的单片机应用软件设计中，“任务”是一个很重要的概念。把一个应用系统分为多少个任务且定义每一个任务各负责什么事情，这是一门艺术。对于任务的划分，并没有一个人人都要遵守的规则，不同的人来设计一个同样规格要求的系统，会有不同的方案。但一般来说，任务划分有3个原则。  

- 相同外设同一任务  
  对每个独立的硬件(例如串行通信端口)进行操作的驱动程序段放在一个任务中。也就是说，要想对某个设备资源进行操作，只有依靠执行相应的任务来实现。这样无论何时切换任务，都不会对任何独立的“外设”造成影响。  
  这样做能够避免嵌入式操作系统的特殊问题——资源冲突和重入问题，而且利于系统维护与升级。所谓“资源冲突”，就是任务A在访问某个资源时，恰好发生了任务切换——由任务A切换到任务B，任务B也访问这个资源且改变了它的状态，这样当再次执行任务A时，就可能发生冲突或带来不确定性。而所谓“重入”，是指假设任务A在运行某个函数，发生任务切换后，任务B也运行这个函数，这样就会破坏任务A执行这个函数时的现场，从而可能导致任务A执行函数时结果不正确。这种问题尤其容易出现在串行接口器件的操作中，例如串口，串行的A/D、D/A器件等。  

- 增加任务提高实时  
  1. **长任务**  
     在嵌入式多任务实时系统中，任务是指一个程序分段。这个程序分段被操作系统当作一个基本单元来调度。典型地，每个任务都是一个无限的循环。  
	 RTOS本质上就是嵌入的实时内核，它负责管理各个任务，或者说是为每个任务分配CPU时间，并且负责任务之间的通信。实时内核可分为可剥夺型和不可剥夺型两类。因此，按照所使用内核的不同，嵌入式实时系统也可分为两类：使用不可剥夺型内核的嵌入式实时系统和使用可剥夺型内核的嵌入式实时系统。  
	 在RTOS中，长任务就是指整个任务的执行时间较长，超出了RTOS中其他某一个或某几个任务的实时要求容限，而对整个RTOS的实时性构成威胁的那些任务。需要注意的是，长任务与复杂任务不能混淆，复杂任务的执行时间不一定长，简单任务也可能会构成长任务。  
	 当使用可剥夺型实时内核时，长任务由于执行的时间较长，因而更容易被高优先级的任务打断；一旦高优先级的任务进入了就绪状态，当前任务的CPU使用权就被剥夺了，或者说任务被挂起了，那个高优先级的任务立刻得到了CPU的控制权。这样会出现两个问题：一是长任务可能在一次执行的过程中被频繁打断，长时间得不到一次完整的执行；二是长任务被打断时，可能要保存大量的现场信息，其目的是为了保证在高优先级任务执行完返回后，长任务能得以继续执行。然而，这样做要占用一定的系统资源，同时保存现场本身也是要占用CPU时间的，因此，实时性也会下降。  
	 当使用不可剥夺型实时内核时，长任务对RTOS的影响更为明显，因为在这种内核中，任务的响应时间取决于最长的任务执行时间。也就是说，由于长任务的存在，任务的响应时间要变长。其结果是CPU长时间停留在长任务中，其他任务得不到实时的响应，甚至根本得不到执行，系统的实时性势必要下降。  
	 解决长任务问题最有效的途径是进行任务分割。所谓“任务分割”是指将影响系统实时性的长任务分割成若干个小任务。这样单个任务的执行时间变短，系统的任务响应时间变短，实时性得以提高。  
	 
  2. **任务执行时间计算分析**  
     当然，长任务的分割必须结合系统中所使用的内核，以及各任务对实时性的要求等情况，进行必要的分析与计算，才能保证分割的合理性和有效性，具体的步骤如下。  
	 1. 分析系统任务数量及执行优先级，求出每个任务所要求的最低执行频率(f1，f2，…，fn)。  
	 2. 计算目前每个务的实际执行时间(t1，t2，…，tn)。  
	 3. 确定系统中的长任务。如果 max(t1，t2，…，tn) ≤ min(1/f1，1/f2，…，1/fn)，则此系统中不存在长任务。如果 max(t1，t2，…，tn) ＞ min(1/f1，1/f2，…，1/fn)，则此系统中存在长任务，且执行时间为max(t1，t2，…，tn)的那个任务就是要寻找的长任务。  
	 4. 分析这个长任务是否要分割，分析是什么原因导致执行时间过长，是否能够通过程序的优化来缩短？如果能，则优化程序不进行任务分割；否则，对这个长任务进行分割。  

  3. **实施长任务分割**   
     常用的任务分割的方法有以下两种：  
	 1. 将长任务按功能分为若干模块，每个模块构成一个小任务，每个小任务实现一种独立功能，保证执行时间t。  
	 2. 有的长任务比较特殊，例如键盘任务和动态LED数码管显示任务，很难按照上面的方法把它分成若干个功能相对独立的小模块。这时，一般是按照方便保存现场信息的原则，将其强制分割成若干个小任务，每个小任务在min(1/f1，1/f2，…，1/fn)时间内主动保存现场信息、放弃CPU的控制权，等到再次被内核调度时继续执行。这种分割方法相对而言较复杂，各任务之间界限不是很明显，看似未经分割，但实际上它却是由多次任务中断来完成的。  

  总之，无论是使用可剥夺型内核，还是使用不可剥夺型内核，长任务都会对RTOS构成严重的威胁。  

- 软件解耦数据优先  
  可以采用软件工程中的解耦原则对应用程序进行任务的划分。任务之间的耦合是影响软件复杂程度的一个重要因素，应该采取下述设计原则：尽量使用数据耦合，少用控制耦合和特征耦合，限制公共环境耦合的范围，完全不用内容耦合。

### 关于模块间耦合的分类  
1. 内容耦合(Content Coupling)   
   如果发生下列情形，两个模块之间就发生了内容耦合。  
   - 一个模块直接访问另一个模块的内部数据；  
   - 一个模块不通过正常入口转到另一模块内部；  
   - 两个模块有一部分程序代码重叠(只可能出现在汇编语言中)；  
   - 一个模块有多个入口。  

2. 公共耦合(Common Coupling)   
   若一组模块都访问同一个公共数据环境，则它们之间的耦合就称为公共耦合。公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。   

3. 外部耦合(External Coupling) 
   一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。   

4. 控制耦合(Control Coupling)  
   如果一个模块通过传送开关、标志、名字等控制信息，明显地控制选择另一模块的功能，就是控制耦合。  

5. 印记耦合(Stamp Coupling)   
   如果一组模块通过参数表传递记录信息，就是标记耦合。它是某一数据结构的子结构，而不是简单变量。  

6. 数据耦合(Data Coupling)    
   如果一个模块访问另一个模块时，彼此之间是通过数据参数(不是控制参数、公共数据结构或外部变量)来交换输入、输出信息的，则称这种耦合为数据耦合。  

7. 非直接耦合(Nondirect Coupling)    
   如果两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的，这就是非直接耦合。这种耦合的模块独立性最强。   
