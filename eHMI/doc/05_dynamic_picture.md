动态画面  
---
### 动态的本质及其构成要素  

在设计动态画面之前，有必要先来辨析一个概念，何谓“动态”。  

这里“动态画面”所谓的动态，和编程中所遇到的“动态”概念并不完全相同，而非常类似于动态网页这种“动态”的概念。静态网页是指存放在服务器文件系统中，实实在在存在着的HTML文件（文本格式）。当用户在浏览器中输入页面的URL，然后回车，浏览器就会将对应的HTML文件下载、渲染并呈现在窗口中。动态网页是相对于静态网页而言的。当浏览器请求服务器的某个页面时，服务器根据当前时间、环境参数、数据库操作等动态的生成HTML页面，然后再发送给浏览器（后面的处理就跟静态网页一样了）。很明显，动态网页中的“动态”是指服务器端页面的动态生成，相反，“静态”则指页面是实实在在的、独立的文件。  
可以很明显的看到，在上述概念中，所谓静态，就是把提前描述好的文件显示出来即可；而所谓动态，就是根据某些特定数据实时的构造出所要呈现给用户的画面。  

上次学习会中提出的画面是一个“纯粹”的静态画面，因为，它要在320x240的画面上部——左上角坐标为（10，30）的位置开始描画一个长300，高80的Label，Label上的文字为“Welcome to this sample!”，用红色显示。看，这一切都是实现安排好的，没有任何变化的余地，这样的画面就可以称为“静态画面”。  

那么在我们的嵌入式系统画面环境中，所谓“动态画面”，又包含哪些元素呢？   

1. 测试数据或图像的刷新  
某画面中显示了多个表示不同测量数据的文本框，由于测量数据是实时在变化的，因此画面上各文本框中显示的数值也在不断变化。这样的画面应该如何来实现？  

2. 用户对某些设定项目的选择  
某画面中显示了多个用户设定项目，当用户通过某种方式修改了这些设定项目的值，画面必须依据用户的修改而尽快改变要显示的结果。这样的画面应该如何来实现？  

3. 画面之间的切换  
有多个不同的画面，当某个画面中做了某个特殊的操作或是满足了某个特定的条件（比如按下某个按钮，又或者是等待了一定的时间），系统会切换到另一个画面。这样的操作应该如何来实现？  

画面显示是一个充满了“动态”的地方，因为它和用户的操作高度相关，这也正是画面程序用C++语言开发要优于用C语言开发的主要原因。必须说明，以上提到的只是众多动态显示特性当中的冰山一角，实际工程中所遇到的画面动态特性会随着具体应用呈现出异常复杂的形式。但因为以上三种特性已经大约覆盖了我们这个简单的Sample系统动态显示框架中的所有处理，因此对于其它的动态特性，就不在此进行过多描述了。   

### 动态描画要考虑哪些问题  

以上虽然设想了几个具体的画面，但不妨先来考虑一个最基本的问题——到底什么才能算是一个画面？有人可能会想，这还不简单，按前面讲的，一个背景加一堆控件，不就组成是一个画面了吗？没错，可这说的是静态画面的情形。当引入了动态画面这个概念以后，画面这个概念其实在一定程度上被模糊化了。为什么呢？考虑一下这种情形，当按下某个画面上的Button时，该画面上会添加一个Label，请问添加Label后的画面和添加Label前的画面还算是同一个画面吗？大家可能说是。那么好，如果按下Button后，该画面上添加了十个Label，请问此时的画面和按下Button前还是同一个画面吗？可能还有人说是。那么好，如果按下Button后，该画面上不仅添加了十个Label，还删除了五个既存的Label，并且增加了一幅图像和三个文本框……恐怕这时不会有人说这还是同一个画面了吧。  
问题来了，到底画面要变化到何种程度，才应该被设计成两个不同的画面呢？答案是不确定！没错，到了这个级别的设计，很多问题将不存在标准答案，一切以现实的需求和对变化把握为准。所以，动态画面表示的第一步是如何拆分画面。  

理解了“画面”的相对性，再来看上面提到的三种动态描画。按照“画面”是否切换，上述描画可以分为两种情形，一种是“画面”不切换，“画面”中的显示内容改变，另一种是整个“画面”发生切换。如果以最朴素的方式来思考这两类动态描画，最可能的想法会是什么？重绘，没错，就是重绘整个画面，也就是说每当一个可能影响画面表示的消息被接收到的时候，只需要像第一次生成该画面时所做的一样，在当前这个时点重新取得所有构成画面的信息，重新描画画面的背景及所有控件即可。这样虽然是可行的，但是会有一个很明显的问题——描画的负担过重，或者说描画的效率太差。  
即使不是处于嵌入式系统环境，重绘整个画面都将是一个负担极重的工作，想象一下，类似测试数据刷新的情况，如果定时的周期是50ms，那就意味着每50ms就需要把当前整个画面重画一遍，这样，也许系统就没时间做别的处理了！这显然是一个很笨的办法，即使是Windows这种通用操作系统（通常它会跑在处理能力很强的CPU上），也不会采取这么蹩脚的办法来进行重绘，更何况是RTOS和MCU的环境。  
如果全面重绘是不适合的，那应该以何种单位来响应消息接收时的画面动作呢？这又是一个需要具体分析的问题。以控件为单位也许是一个好的选择，但某些情况下，可能还是无法预知某消息对哪些控件发生了影响，比如数据更新这样的消息，那么此时，重绘整个画面也可能是不得已的选择。  

上面提到了以控件为单位来响应消息，但是这又带来另一个问题——如果消息的最终响应者是控件，那么控件应该如何来封装对消息的响应呢？这个问题乍看上去不太好懂，其实意思是说，假如控件对某个消息的响应是修改画面中其它控件的显示，那么，这样一种“未卜先知”的操作可以被封装在控件类的操作之中吗？再说的通俗一些，由于控件已经被独立、静态的被抽象了出来，它是不可能知道自己在某个具体画面的具体时间点上，应该如何改变其它控件的，但是消息的最终处理权却丢给了它，那它该怎么办呢？  

针对以上这些问题，下文将一一给出解决方案，但请理解，解决方案决不是唯一的，当应用场景发生变化时，这里所介绍的解决方案可能会变得不合适，还得回到“具体问题具体分析”这句老话。这里只想强调下，实现动态描画其实还是有很多问题需要考虑的，或者说，是需要从更高的层面进行抽象的。  

下面就来具体讨论下，针对上面提出的问题，某系统的HMI框架中是如何实现的。  

### 如何划分画面  

从时间和空间俩个维度来看，什么范围才应该被划分为一个独立的画面对象呢？当然怎么划分都是可以的，但从式样要求和描画效率两个角度来考虑，有一些自然比较适合的原则应该遵守。  

第一，式样的一些规定自然划分了画面的种类，比如，两个画面都是测量数据的动态刷新，但一个是为了向用户展示温度信息，一个是为了向用户展示电压信息，即使这两个画面的布局一模一样，它们也还是应当被划分为两个画面才比较好处理。理由呢，虽然表示上它们是非常类似的，但由于两个画面的用途不同，这可能造成它们被调用的时机，以及背后驱动它们发生变化的数据逻辑和消息驱动机制都是完全不同的。在此情况下，如果统一在同一个画面反而会造成画面内部发生很多切换逻辑，这种统一就显得没有必要了。当然，可以考虑采用继承的方式来提高代码的复用性，但从画面逻辑来看，它们显然还是做成不同的画面对象比较合适。  

第二，同一画面对象中的控件，其空间布局尽量不要发生变化。为什么要提到这一点呢，这是为了代码的效率考虑的。如果两个画面都只显示了十个测量数据，但是，它们的空间布局完全不同，此时要将这两个画面作为一个画面对象来处理的话，可以想见，在两种情形切换时，由于控件的位置都发生了变化，那么即使显示内容完全相同，整个画面也几近重绘，此时，将它们统一为一个对象的意义已经不大了。  

其实划分画面有一个总的原则就是，在画面单位内部响应变化的时候，我们所做的处理（包括描画处理和后台逻辑）尽量少。反之，如果达不到这一点，那么就不如划分成两个不同的画面对象。  

划分了不同的画面后，方便起见，可以用不同的画面ID来表示不同的画面。  

### 画面内的消息流动 

截止上一次所作的静态画面的练习，HMI的消息的处理都是停留在画面这一级的，如果不是抽象出了控件这个东东，由画面来统一处理消息当然也没什么问题。但是，当控件这家伙出现之后，我们不禁要想，是不是所有的消息都应该停留在画面这一层呢？  

想象一个具体的例子，当用户在触摸屏上“按下”了某画面上的一个Button，这个动作会触发一个“按下”消息，这个消息首先会被发送给当前的画面对象，画面可以根据这个消息自行处理，此时，画面得先判断这个“按下”消息的意图，它是发给哪个控件的？如果是发给Button这类可以响应“按下”消息以外的控件，那么无视这个操作，如果是发给Button这类可以响应“按下”消息的控件，那么再去调用Button控件的描画方法来修改控件的显示状态，然后再判断这样一个操作会引发什么样实质逻辑，继而进行这些具体的处理。  

在上面的分析中可以看到，一个针对某一控件的消息会引发两类操作。一类操作是对控件本身的描画操作，比如，Button相对于“按下”消息应该改变自己的背景，同时进行一定的三维表示。另一类操作是这一消息的真实意图所对应的处理，这些处理已经不仅仅局限于该控件本身了，它可能需要修改其它控件的表示，乃至于切换整个画面。  

问题来了，有必要将这个消息下放给控件进行处理吗？由于实质逻辑不局限于这个特定控件本身，所以有人会觉得下放这一消息没有意义。但是应该看到另一点，即此时对控件本身的描画操作是一个广泛的存在。上面说明了在Button按下时，控件本身有一个很特别的描画操作，那么其它控件呢，比如Combox，比如Icon，比如Checkbox，比如ScrollBar，等等，这些东东在消息到来时其自身的描画都遵循一个特定的规则。从HMI系统的设计角度来看，这一统一处理如果不被抽象，那么画面自身处理的复杂度将会大大增加，同时也违反了代码复用的原则。  

关于此处的利弊权衡还有另一个更为重要的因素不得不考虑。截止目前我们只考虑了单层画面和单层控件的情形，但是HMI系统将来很有可能要扩展到的一种情况就是支持多层画面和多层控件。举例来说，如果未来需要考虑在画面上弹出Dialog，而且允许Dialog进行叠加，那么将消息截流在父画面这一级问题就很大了，因为处理的主体明显不是父画面，而是画面上的Dialog。  

综合上面这些分析，消息从底层画面开始层层向上传递至最顶层的控件，看来才是一个更为合理的选择。但是别忘了，前面还提到过，对于消息引发的另一类操作，即实质逻辑的处理由该如何进行呢？这其实就是上文提到的那个“未卜先知”的问题，不急，这个问题的处理方法在后面再进行说明。  

### 消息种类及其对描画的影响  

所谓“画面”的动态显示，无非是根据接收到的消息决定画面迁移还是修改画面中控件的具体表示。为了整清楚消息对画面究竟会产生哪些影响，必须先来梳理一下可能的消息种类。  

从上面举的三个例子来看，消息按照它们的来源可以粗略的分为两种：一种来自于画面外部，一种来自于针对画面自身的操作（从触摸屏或按键而来）。  

对于来自于画面外部的消息，常见的又有两类，一类是定时消息，另一类是像数据更新这种非定时消息。定时消息可以由系统的定时器来触发，而数据更新消息，则需要其它任务主动向HMI任务发送。但这里，消息的来源不是考虑的重点，消息对画面中控件的影响才是应该被重点关照的。显然，定时消息对所有控件都是“一视同仁”的，它的涵义非常明确。换句话说，什么控件需要发生定时刷新，什么控件不需要定时刷新，这很容易区别。比如，静态的Label控件，这类控件都不需要定时刷新，而用于显示测量数据的Digit控件，这类控件必须定时刷新。经过这样的划分，定时消息便可放心大胆的交给控件自身去处理。具体的方式呢，可以考虑画面类持有一个Update方法，控件类也都持有自己的Update方法，当然不需要定时刷新的控件什么都不做就可以了。画面类的Update方法会挨个调用画面上所有控件的Update方法。在HMI的消息循环中，一旦接收到定时消息，就可以调用这个画面类的Update方法，而最终每个控件是否定时更新就转交给了每个具体的控件独自来考虑，这样一来就避免了对无效区域的重绘，提高了画面整体的描画效率。  

再来看数据更新这种消息。如果针对每一种数据都单独制作一种数据更新消息的话，倒是便于将此种消息绑定在特定的控件上，但是，这样做几乎总是不现实的，因为系统中的数据种类通常是纷繁复杂的，将每一种数据的更新都单独做成一种消息，会造成消息本身的数量大规模膨胀，反而会降低系统的效率和软件的可维护性。一种可行的方法是采用一个抽象的数据更新消息，系统中任何数据（当然，能够明确判断和HMI无关的更新除外）的更新都会触发这个消息。但是这样会产生另外一个问题，就是这个消息不能方便的绑定在某些特定的控件上了。在这种情况下，简单的思路还是需要的，没错，就是前面所提到的对整个画面进行重绘。也就是说，这种消息会被截留在画面对象之中，由画面主动的发起每个控件的重绘动作，而不是将消息传递给画面上的每个控件。  
还有没有更好的方法呢？也还是有的。由于控件要不要更新的问题已经在上述Update方法中得以体现，因此在数据更新消息中，其实并不需要立即显示这些更新后的数据，它们的描画动作可以延迟到定时消息触发后再进行。这样一来，如果HMI可以将其要显示的数据对象也抽象出来的话，在数据更新消息中，其实只需要更新这个数据对象就OK了。某系统的HMIDataManager类就是关于HMI数据对象的抽象，因为此次的示例并不打算模拟这一部分，所以这里的处理就不做过多解释了，有兴趣的同志可以去看某系统的源代码。  

最后再来看下来自于画面自身的消息。前面说过了，这些消息通常是由触摸屏或按键触发而来。可能大家已经发现了，这种消息都伴随着一个坐标信息（或序号信息），它有个比定时消息更有利于处理的特征，即它天然绑定在某个具体的控件之上，这样一来只要用处理定时消息的思路来处理它就好了。比如从触摸屏那可以触发“按下”消息，那么考虑在画面类中实现一个TDown方法，每个需要响应此类动作的控件也都实现自身的TDown方法，然后再在画面类的TDown方法中检索应该将此消息传递到画面上的哪一个控件（调用哪一个控件的TDown方法）。当“按下”消息被触发时，就可以调用这个画面类的TDown方法，再由画面的TDown方法将消息推送到某个具体控件的TDown方法中。  

### 回调机制  



### 核心动态描画处理  

讲了这么多，其实在示例工程中，上述设计思想都集中在两个类的设计之中，即SCBoard类和SCParts类，下面给出它们的头文件。关于具体画面和控件的实现代码可以参考示例工程的最终代码。  
  
```C++
///
/// class : SCBoard
/// Board class
///
class SCBoard : public SCCore {
public :
	SCBoard(const SCRect& area, const short id = -1); // -1: illegal ID
	virtual ~SCBoard();

	void			RegistParts(SCParts* target);
	void			UnregistParts(SCParts* target);
	void			DestroyParts(SCParts* target);
	void			DestroyAllParts(void);
	
	void			Initialize(void);
	virtual bool	Draw(void);
	virtual bool	DrawBackground(void);
	virtual bool	Update(void);
	
	virtual void	TDown(const SCPoint& point);
	virtual void	TUp(const SCPoint& point);
	virtual void	TMove(const SCPoint& point);
	SCParts*		GetChild(void) const {return(m_child);}
	SCParts*		GetChild(const unsigned short x, const unsigned short y) const;
	SCParts*		GetChild(const SCPoint& point) const;
	SCParts*		GetChild(const short id) const;
	SCParts*		GetLastChild(void) const;
	SCParts*		GetOperableChild(const SCPoint& point) const;

	short			GetScreenID() {return(m_screen_id);}

protected :
	short			m_screen_id;	// screen ID
	SCParts*		m_child;		// child parts
	SCParts*		m_captured;		// part on touch event
	SCPoint			m_touch_point;	// touch point (for Callback)
};
```

```C++
///
/// class : SCParts
/// Parts class
///
class SCParts : public SCCore {
public :
	SCParts(const short id, const SCRect& area,
			const XColor fore_color = COLOR(Black),
			const XColor back_color = COLOR(Transparent));
	virtual ~SCParts();

	virtual void	Initialize() {}
	virtual bool	Draw(void) = 0;
	virtual bool	DrawBackground(void);
	virtual bool	ReDraw(void);
	virtual bool	Update(void);
	virtual void	TDown(const SCPoint& point);
	virtual void	TUp(const SCPoint& point);
	virtual void	TMove(const SCPoint& point);
	void			AddCallback(SCCallback* cb); // TODO : ?
	void			DoCallback(const int type);

	SCBoard*		Parent(void) const {return(m_parent);}
	void			Parent(SCBoard* parent) {m_parent = parent;}
	SCParts*		Next(void) const {return(m_next);}
	void			Next(SCParts* next) {m_next = next;}
	SCParts*		Prev(void) const {return(m_prev);}
	void			Prev(SCParts* prev) {m_prev = prev;}
	short			GetID() const {return(m_id);}
	bool			GetVisible(void) const {return(m_visible);}
	void			SetVisible(bool visible) {m_visible = visible;}
	bool			GetPushed(void) const {return(m_pushed);}
	void			SetPushed(bool pushed) {m_pushed = pushed;}
	
protected :
	void			removeAllCallbacks(void);

protected :
	short			m_id;			// part ID
	SCBoard*		m_parent;		// father screen
	SCParts*		m_next;			// next part by register sequence
	SCParts*		m_prev;			// previous part by register sequence
	SCCallback*		m_callback;		// call back list pointer
	bool			m_visible;		// visible?
	bool			m_pushed;		// in push state?
	XColor			m_fore_color;	// foreground color
	XColor			m_back_color;	// background color
};
```
